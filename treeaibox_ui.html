<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>TreeAIBox UI</title>
  <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      overflow-x: hidden;
    }
    
    .container {
      width: 98%;
      margin: 10px auto;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background: #f9f9f9;
  border-bottom: 1px solid #ddd;
}
    
.header-left {
  display: flex;
  align-items: center;
  flex: 5;
}

.header-logo {
  height: 40px;
  margin-right: 20px;
  margin-left: 5px;
}

.title {
  font-size: 19px;
  font-weight: bold;
}
.header-right {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-right: 15px;
}

.header-link {
  display: flex;
  align-items: center;
  color: #333;
  text-decoration: none;
  font-size: 14px;
  gap: 5px;
}

.header-link:hover {
  color: #4a86e8;
}

.header-link img {
  height: 24px;
  width: auto;
}



.home-icon {
  font-size: 20px;
}
    .gpu-option {
      flex: 1;
      text-align: right;
      border: 1px solid #ccc;
      padding: 5px 10px;
      border-radius: 4px;
      background: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .gpu-option label {
      font-size: 16px;
      font-weight: bold;
      margin-left: 5px;
    }

    .gpu-option input[type="checkbox"] {
      width: auto;
      margin: 0;
      vertical-align: middle;
    }

    .tabs {
      display: flex;
      background-color: #f0f0f0;
      border-bottom: 1px solid #ddd;
    }

    .tab {
      padding: 12px 20px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-right: 1px solid #ddd;
    }

    .tab.active {
      background-color: white;
      border-bottom: 2px solid #4a86e8;
    }

    .tab-content {
      display: none;
      padding: 20px;
      overflow-x: hidden;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    .about-box-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 10px;
    color: #4a86e8;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
  }

  .image-caption {
    text-align: center;
    font-size: 14px;
    color: #666;
    margin-top: 10px;
    font-style: italic;
  }

  #about-content .reference-box {
    margin-bottom: 15px;
    max-height: none;
  }

  #about-content .reference-box p {
    margin: 8px 0;
  }

  #about-content .reference-box ul {
    margin: 8px 0;
    padding-left: 20px;
  }

  #about-content .reference-box li {
    margin-bottom: 8px;
  }

    .section-title {
      font-size: 20px;
      font-weight: bold;
      margin: 0px 0 5px 0;
      text-align: center;
    }

.content-row {
  display: flex;
  position: relative;
  width: 100%;
  overflow-x: hidden;
}

.image-container {
  /* Fixed width after user adjustment */
  width: 30%;
  min-width: 200px;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 80vh;
  border: 1px solid #ddd;
  flex: 0 0 auto; /* This prevents the container from growing or shrinking */
}

.controls-container {
  /* Flex to take remaining space */
  flex: 1 1 auto; /* This allows the container to grow and shrink */
  display: flex;
  flex-direction: column;
  overflow-x: hidden;
  min-width: 300px; /* Minimum width for controls */
}

.handle {
  width: 10px;
  flex: 0 0 10px; /* Fixed width for handle */
  background-color: #e0e0e0;
  cursor: col-resize;
  user-select: none;
  position: relative;
  z-index: 10;
  margin-right:5px;
}

.handle:hover, .handle.active {
  background-color: #4a86e8;
}

.handle::after {
  content: "⋮";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-weight: bold;
}



    .resizable-image {
      width: 100%;
      /*max-width: 600px;*/
      height: auto;
      /*border: 1px solid #ddd;*/
      border: none; /* Remove the border from images */
    }

    .warning-box {
      font-size: 14px;
      margin: 5px 0;
      padding: 8px;
      border: 1px solid #ccc;
      background-color: #f9f9f9;
    }
    .warning-button {
      background-color: #ff9800;
      color: white;
      margin-left: 5px;
    }

    .warning-button:hover {
      background-color: #e68a00;
    }
    .option-group {
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 5px;
      background-color: #f9f9f9;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10 and IE 11 */
      user-select: none; /* Standard syntax */
    }

    .option-group-title {
      font-size: 14px;
      padding: 8px;
      border-bottom: 1px solid #ddd;
      background-color: #eee;
    }

    .option-group-content {
      padding: 10px;
      font-size:14px;
    }


    /* Remove default marker (works in WebKit browsers) */
.option-group .option-group-title::-webkit-details-marker {
  display: none;
}

/* Remove default list styling in other browsers if necessary */
.option-group .option-group-title {
  list-style: none;
  cursor: pointer;
  position: relative; /* Allows the pseudo-element to be positioned relative to the title */
  padding-right: 2em; /* Add space on the right for the triangle */
}

/* Add the custom triangle using ::after */
.option-group .option-group-title::after {
  content: '▼';  /* Down arrow when collapsed */
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  transition: all 0.3s ease;
  font-size: 1em; /* Adjust as needed */
  color:gray;
}

/* When the details element is open, change the triangle to up arrow */
.option-group[open] .option-group-title::after {
  content: '▲';
  color:darkgray;
}

    .radio-option {
      margin-bottom: 5px;
      display: inline-flex;
      align-items: center;
      margin-right: 20px;
      cursor: pointer;
    }

    .radio-option label {
      display: inline-block;
      vertical-align: middle;
      margin-left: 4px;
      cursor: pointer;
    }

    .radio-option input[type="radio"] {
      vertical-align: middle;
      margin-top: 0;
      margin-bottom: 0;
      width: auto;
      padding: 0;
      cursor: pointer;
    }
    .radio-option input[type="checkbox"] {
      vertical-align: middle;
      margin-top: 0;
      margin-bottom: 0;
      width: auto;
      padding: 0;
      cursor: pointer;
    }
    .checkbox-option {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .checkbox-option label {
      margin-left: 5px;
      cursor: pointer;
    }

    .checkbox-option input[type="checkbox"] {
      width: auto;
      margin-left: 5px;
      margin-top: 0;
      margin-bottom: 0;
      cursor: pointer;
    }

    .select-option {
      margin-bottom: 5px;
      display: flex;
      align-items: flex-start;
    }

    .select-model-container {
      flex: 1;
      margin-right: 10px;
    }

    .select-option-title {
      font-size: 16px;
      margin-bottom: 10px;
      margin-top: 5px;
    }

    /* When the checkbox is not checked, set the label opacity to 0.5 */
    #tile-enable:not(:checked) + label {
      opacity: 0.5;
    }

    /* When the checkbox is checked, restore full opacity */
    #tile-enable:checked + label {
      opacity: 1.0;
    }
    /* Use :has() to update the dtm-tile-size input opacity based on checkbox state */
    .parameter-row:has(#tile-enable:not(:checked)) #dtm-tile-size {
      opacity: 0.5;
    }
    .parameter-row:has(#tile-enable:checked) #dtm-tile-size {
      opacity: 1.0;
    }

    .button-container {
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      margin-top: 5px;
    }

    select, input {
      width: 100%;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .button-row {
      display: flex;
      flex-direction: column;
    }

    button {
      padding: 8px 15px;
      background-color: #4a86e8;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-bottom: 5px;
    }

    button:hover {
      background-color: #3773d3;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .full-width-button {
      width: 100%;
      /*margin-top: 10px;*/
      padding: 10px;
      font-size: 14px;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      margin-top: 15px;
    }

    .progress {
      width: 0%;
      height: 100%;
      background-color: #4a86e8;
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    /* Create a horizontal layout for parameter pairs */
    .parameter-pair {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0;
      width: 95%;

    }

    /* Adjust each parameter container within the pair */
    .parameter-pair .parameter-container {
      display: flex;
      flex-direction: column;
      width: 48%; /* Give a bit of space between them */
    }

    /* Style for the labels */
    .parameter-pair .parameter-label {
      white-space: nowrap;
      margin-bottom: 4px;
      font-size: 12px;
    }

    /* Style for the inputs */
    .parameter-pair .parameter-input {
      width: 70%;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      margin-top: 2px;
    }
    .parameter-row .slider{
      width: 70%;
      margin-bottom: 0;
    }

input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  background: transparent;
}

input[type="range"]::-webkit-slider-runnable-track {
  height: 8px;
  background: #ddd;
  border-radius: 4px;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 20px;
  width: 20px;
  border-radius: 50%;
  background: #4a86e8;
  margin-top: -6px; /* centers thumb vertically on the track */
  /* You might adjust any horizontal margins if needed */
}

    /* TreeisoNet specific styles */
    .module-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      margin-bottom: 10px;
    }

    .module-box {
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 5px;
    }

.module-title {
  font-weight: bold;
  font-size: 14px;
  border-bottom: 1px solid #eee;
  padding: 5px;
  position: relative; /* For absolute positioning */
  display: flex;
  align-items: center;
}

/* Radio button standard positioning */
.module-title input[type="radio"] {
  width: 15px;
  height: 15px;
  margin: 0;
  padding: 0;
  cursor: pointer;
}

/* Text label positioning */
.module-title-text {
  margin-left: 10px;
  cursor: pointer;
}

/* Specific styling for the clean button */
#noise-clean-btn-container {
  position: absolute;
  right: 5px;
  top: 50%;
  transform: translateY(-50%);
}

#noise-clean-btn {
  margin: 0;
  padding: 4px 8px;
  font-size: 12px;
}

.module-box .parameter-input {
  width: 90%; /* Change to use full width of parent */
  box-sizing: border-box; /* Include padding and border in the width */
}

/* Ensure consistent layout for parameter rows */
.module-box .parameter-row {
  display: flex;
  flex-direction: column;
  width: 48%; /* Keep to match your current layout */
}

/* Adjust the parameter pair container */
.module-box .parameter-pair {
  display: flex;
  justify-content: space-between;
  width: 100%;
  /*margin-bottom: 10px;*/
}

    .module-content {
      display: flex;
      flex-direction: column;
    }

    .sub-option {
      margin-left: 10px;
      margin-top:5px;
    }

    /* QSM tab styles */
    .qsm-section {
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 5px;
      background-color: #f9f9f9;
    }

    .qsm-title {
      font-size: 16px;
      padding: 8px;
      border-bottom: 1px solid #ddd;
      background-color: #eee;
      font-weight: bold;
    }

    .qsm-content {
      padding: 10px;
    }

    .input-groups-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      align-items: center;
    }

    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      width: 48%;
    }

    .input-group label {
      flex: 3;
      font-size: 14px;
      margin-right: 5px;
      margin-bottom: 0;
      line-height: 1.2;
      align-self: center;
    }

    .input-group input {
      flex: 1;
      width: 60px;
      padding: 4px;
      margin-bottom: 0;
      height: 24px;
    }
    .input-group button {
      align-items: center;
      margin-left: 5px;
    }

    /* Status notifications */
    .notification {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-size: 14px;
      display: none;
    }

    .notification.success {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .notification.error {
      background-color: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    .notification.warning {
      background-color: #fff3cd;
      border: 1px solid #ffeeba;
      color: #856404;
    }

    .notification.info {
      background-color: #d1ecf1;
      border: 1px solid #bee5eb;
      color: #0c5460;
    }

    /* Select styling */
    select option.downloaded {
      color: blue;
    }

    select option.not-downloaded {
      color: #999;
    }

    /* Container to allow relative positioning of the value display */
    .slider-container {
      position: relative;
      display: inline-block;
    }

    /* Style for the slider thumb value display */
    .slider-handle-value {
      position: absolute;
      top: 50%;               /* Adjust as needed to align vertically */
      transform: translate(-50%, -150%);
      background: #fff;
      padding: 2px 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 12px;
      pointer-events: none;   /* Ensure the label does not interfere with slider interactions */
    }

.reference-box {
  position: relative; /* Add this to position the copy button correctly */
  font-size: 14px;
  margin-bottom: 5px;
  padding: 8px;
  border: 1px solid #ddd;
  background-color: #fff;
  overflow-y: auto;
}
/* Special positioning for copy button tooltip */
.reference-box .tooltip {
  position: absolute;
  right: 8px;
  display: inline-block;
  top:0;
}

.reference-box .tooltip .tooltiptext {
  right: 0;
  left: auto;
  margin-left: 0;
  width: 160px; /* Narrower width for this specific tooltip */
  text-align: center;

}

/* Adjust the arrow position for this specific tooltip */
.reference-box .tooltip .tooltiptext::after {
  left: 93%; /* Position the arrow more to the right */

}
.reference-box a {
  color: #4a86e8;
  text-decoration: none;
  word-break: break-all;
  cursor: pointer; /* Make it obvious it's clickable */
}

.reference-box a:hover {
  text-decoration: underline;
}
/* Adjust the copy button positioning since it's now inside a tooltip div */
.copy-btn {
  position: static; /* Change from absolute to static */
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 4px;
  color: rgba(0, 0, 0, 0.5);
  font-size: 16px;
  margin: 0;
  top: 0;
}
/*.copy-btn {*/
/*  position: absolute;*/
/*  top: 0;*/
/*  right: 8px;*/
/*  background: transparent;*/
/*  border: none;*/
/*  cursor: pointer;*/
/*  padding: 4px;*/
/*  color: rgba(0, 0, 0, 0.7);*/
/*  font-size: 16px;*/
/*  margin: 0;*/
/*}*/

.copy-btn:hover {
  color: #4a86e8; /* Keep the hover color as is */
}

/* Tooltip for copy confirmation */
.copy-tooltip {
  position: absolute;
  right: 30px;
  top: 8px;
  background-color: #333;
  color: white;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 12px;
  display: none;
}

.copy-tooltip.show {
  display: block;
  animation: fadeOut 2s forwards;
}

@keyframes fadeOut {
  0% { opacity: 1; }
  70% { opacity: 1; }
  100% { opacity: 0; }
}
.disabled {
  pointer-events: none;
  opacity: 0.5; /* or any desired visual cue */
}
    /* Tooltip */
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip .tooltiptext {
    visibility: hidden;
    width: 140px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 5px;
    position: absolute;
    z-index: 1;
    top: 105%;
    left: 50%;
    margin-left: -75px;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none; /* This is the key addition */
    font-size:12px
}

/* Tooltip arrow pointing up */
.tooltip .tooltiptext::after {
    content: "";
    position: absolute;
    bottom: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent #555 transparent;
}

.tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

.download-btn{
  width:140px;
}
.model-path-btn{
  width:140px;
}
  </style>
</head>
<body>
  <div class="container">
    <!-- Header section -->
    <div class="header">
      <div class="header-left">
        <img src="img/treeaibox_logo.svg" alt="TreeAIBox Logo" class="header-logo">
        <div class="title">TreeAIBox: A collection of LiDAR processing snippets for forests and trees</div>
      </div>
      <div class="header-right">
        <a href="#" class="header-link github-link" title="View on GitHub">
          <img src="img/github_logo.svg" alt="GitHub">
          <span>GitHub</span>
        </a>
<!--        <a href="#" class="header-link homepage-link" title="Visit homepage">-->
<!--          <span class="home-icon">🏠︎</span>-->
<!--          <span>Homepage</span>-->
<!--        </a>-->
      </div>
      <div class="gpu-option">
        <input type="checkbox" id="use-gpu" checked>
        <label for="use-gpu">Use GPU (CUDA)</label>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab" data-tab="treefiltering">TreeFiltering</div>
      <div class="tab active" data-tab="treeisonet">TreeisoNet</div>
      <div class="tab" data-tab="woodcls">WoodCls</div>
      <div class="tab" data-tab="qsm">QSM</div>
      <div class="tab" data-tab="about">About</div>
    </div>

    <!-- TreeFiltering Tab Content -->
    <div class="tab-content" id="treefiltering-content">
      <div class="section-title">Filtering trees from ground and understory</div>

      <div class="content-row">
        <div class="image-container" style="width:40%">
          <img class="resizable-image" id="treefilter-image" src="img/treefiltering_tls.jpg" alt="Tree Filtering Image">
        </div>
        <div class="handle"></div>
        <div class="controls-container">
          <div class="reference-box">
            <div class="tooltip">
              <button class="copy-btn">📄</button>
              <span class="tooltiptext">Copy reference to clipboard</span>
            </div>
            <span class="copy-tooltip">Copied!</span>
            Please reference the publication if you find this tool helpful:
            <br><br>
            Xi, Zhouxin, Chris Hopkinson, and Laura Chasmer. "Supervised terrestrial to airborne laser scanner model calibration for 3D individual-tree attribute mapping using deep neural networks." <i>ISPRS Journal of Photogrammetry and Remote Sensing</i> 209 (2024): 324-343.
            <br>
            <a href="https://doi.org/10.1016/j.isprsjprs.2024.02.010" class="external-link">https://doi.org/10.1016/j.isprsjprs.2024.02.010</a>
          </div>

          <details class="option-group" open>
            <summary class="option-group-title">Sensor</summary>
            <div class="option-group-content">
              <div class="radio-option">
                <input type="radio" id="filter-tls-sensor" name="filter-sensor" checked>
                <label for="filter-tls-sensor">TLS</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="filter-uav-sensor" name="filter-sensor">
                <label for="filter-uav-sensor">UAV</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="filter-als-sensor" name="filter-sensor">
                <label for="filter-als-sensor">ALS</label>
              </div>
            </div>
          </details>

          <details class="option-group" open>
            <summary class="option-group-title">DTM</summary>
            <div class="option-group-content">
              <div class="parameter-row" style="display: flex; justify-content: space-between;align-items: center; margin-top: 0;">
                <div style="display: flex;">
                  <div class="checkbox-option">
                  <input type="checkbox" id="tile-enable">
                  <label for="tile-enable" style="margin-left: 5px">Tile size(m)</label>
                  </div>
                  <input type="number" id="dtm-tile-size" style="width: 70px; margin-left:10px" value="1000" min="0" step="1">
                </div>
                <div>
                  <label for="dtm-resolution" style="margin-left: 10px;margin-bottom: 5px;">Resolution(m)</label>
                  <input type="number" id="dtm-resolution" style="width: 80px;margin-left:10px;" value="1.0" min="0" step="0.5">
                </div>
              </div>

              <div style="display: flex; justify-content: space-between; margin-top: 0;">
                <div style="display: flex; align-items: center; width: 48%;">
                  <label for="dtm-buffer-size" style="margin-right: 10px;margin-bottom: 5px;">Buffer size(m)</label>
                  <input type="number" id="dtm-buffer-size" style="width: 80px;" value="1.0" min="0" step="0.5">
                </div>

                <div class="tooltip">
                    <button id="create-dtm-btn" style="margin-right: 5px;margin-bottom: 5px;margin-top: 5px;">Create DTM</button>
                    <span class="tooltiptext">Create the DTM grid points from the TreeFilter class</span>
                </div>
              </div>
            </div>
          </details>

          <div class="select-option">
            <div class="select-model-container">
              <div class="select-option-title">Predefined models</div>
              <select id="pretrain-treefiltering">
                <!-- Models will be populated dynamically -->
              </select>
            </div>
            <div class="button-container">
              <div class="button-row">
                <div class="tooltip">
                    <button class="model-path-btn">Model path</button>
                    <span class="tooltiptext">Open the folder with downloaded models</span>
                </div>
                <div class="tooltip">
                    <button class="download-btn">Download</button>
                    <span class="tooltiptext">Download the pre-trained model</span>
                </div>
              </div>
            </div>
          </div>

<!--          <button class="full-width-button" id="filter-apply-btn">Apply</button>-->
          <button class="full-width-button apply-btn">Apply</button>
        </div>
      </div>
    </div>



    <!-- TreeisoNet Tab Content -->
    <div class="tab-content active" id="treeisonet-content">
      <div class="section-title">TreeisoNet</div>

      <div class="content-row">
        <div class="image-container" style="width:25%">
          <img class="resizable-image" id="treeisonet-image" src="img/treeisonet_tls.jpg" alt="TreeisoNet Image">
          <object data="dl_visualization.svg" type="image/svg+xml"></object>
        </div>
        <div class="handle"></div>
        <div class="controls-container">
          <div class="reference-box" style="margin-bottom:0">
            <div class="tooltip">
              <button class="copy-btn">📄</button>
              <span class="tooltiptext">Copy reference to clipboard</span>
            </div>
            <span class="copy-tooltip">Copied!</span>
            Please reference the publication if you find this tool helpful:
            <br><br>
            Xi, Zhouxin, and Dani Degenhardt. "A new unified framework for supervised 3D crown segmentation (TreeisoNet) using deep neural networks across airborne, UAV-borne, and terrestrial laser scans." <i>ISPRS Open Journal of Photogrammetry and Remote Sensing </i> 15 (2025): 100083.
            <a href="https://doi.org/10.1016/j.ophoto.2025.100083" class="external-link">https://doi.org/10.1016/j.ophoto.2025.100083</a>
          </div>

          <div class="warning-box">
            TreeisoNet steps: 1. classify stems (if any), 2. extract tree locations (stem bases or tree tops), 3. segment stems or trees, and 4. cluster crowns. Non-AI methods are also optional. You can manually edit intermediate results for optimal results.
          </div>

          <details class="option-group" open>
            <summary class="option-group-title" style="height:12px;padding:5px">Scene</summary>
            <div class="option-group-content" style="padding:5px 0 0 5px">
              <div class="radio-option"> <!-- Change from checkbox-option to radio-option for consistent styling -->
                <input type="checkbox" id="scene-any">
                <label for="scene-any">Any</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="scene-boreal" name="scene" checked>
                <label for="scene-boreal">Boreal</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="scene-mixedwood" name="scene">
                <label for="scene-mixedwood">Mixedwood</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="scene-reclamation" name="scene">
                <label for="scene-reclamation">Reclamation</label>
              </div>
            </div>
          </details>

          <details class="option-group" open>
            <summary class="option-group-title" style="height:12px;padding:5px">Sensor</summary>
            <div class="option-group-content" style="padding:5px 0 0 5px">
              <div class="radio-option">
                <input type="radio" id="sensor-tls" name="sensor">
                <label for="sensor-tls">TLS</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="sensor-uav" name="sensor" checked>
                <label for="sensor-uav">UAV (stem explicit)</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="sensor-als" name="sensor">
                <label for="sensor-als">ALS (stem invisible)</label>
              </div>
            </div>
          </details>

          <details class="option-group" open>
            <summary class="option-group-title" style="height:12px;padding:5px">Modules</summary>
            <div class="option-group-content"  style="padding:5px 0 0 5px">
              <div class="module-grid">
                <!-- Module 1: StemCls -->
                <div class="module-box" id="stemcls-module">
                  <div class="module-title">
                    <input type="radio" id="module-stemcls" name="module" checked>
                    <label class="module-title-text" for="module-stemcls">1. StemCls</label>
                    <div id="noise-clean-btn-container" class="tooltip">
                        <button id="noise-clean-btn" class="sub-option">Remove small clusters</button>
                        <span class="tooltiptext">Remove the isolated clusters based on connected components</span>
                    </div>
                  </div>
                  <div class="module-content">

                    <div class="parameter-pair sub-option">
                      <div class="parameter-row">
                        <label class="parameter-label">Max gap (m)</label>
                        <input type="number" id="clean-max-gap" class="parameter-input" value="3.0" min="0.1" step="0.1">
                      </div>
                      <div class="parameter-row">
                        <label class="parameter-label">Min points</label>
                        <input type="number" id="clean-min-points" class="parameter-input" value="100" min="1" step="1">
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Module 2: TreeLoc -->
                <div class="module-box" id="treeloc-module">
                  <div class="module-title">
                    <input type="radio" id="module-treeloc" name="module">
                    <label class="module-title-text" for="module-treeloc">2. TreeLoc</label>
                  </div>
                  <div class="module-content" id="treeloc-module-content">
                    <!-- Default content for TLS/UAV sensors (now the default) -->
                    <div id="treeloc-cutoff-content">
                      <div class="parameter-pair sub-option">
                        <div class="parameter-row">
                          <label class="parameter-label">Cutoff height ratio (0-1)</label>
                          <input type="number" id="treeloc-cutoff" class="parameter-input" value="0.3" min="0.0" step="0.1">
                        </div>
                      </div>
                    </div>

                    <!-- Alternative content for ALS sensor (initially hidden) -->
                    <div id="treeloc-default-content" style="display: none;">
                      <div class="parameter-pair sub-option">
                        <div class="parameter-row">
                          <label class="parameter-label">Confidence</label>
                          <div class="slider-container">
                            <input type="range" min="0.0" max="1.0" value="0.3" step="0.1" class="slider" id="treeloc-conf-thresh" oninput="updateSliderValue(this)">
                            <span class="slider-handle-value" id="slider-handle-value-conf">0.3</span>
                          </div>
                        </div>
                        <div class="parameter-row">
                          <label class="parameter-label">NMS cutoff</label>
                          <div class="slider-container">
                            <input type="range" min="0.0" max="1.0" value="0.5" step="0.1" class="slider" id="treeloc-nms-thresh" oninput="updateSliderValue(this)">
                            <span class="slider-handle-value" id="slider-handle-value-nms">0.5</span>
                          </div>
                        </div>
                      </div>
                      <div class="parameter-pair sub-option">
                        <div class="parameter-row">
                          <label class="parameter-label">Max gap (m)</label>
                          <input type="number" id="treeloc-max-gap" class="parameter-input" value="0.3" min="0.0" step="0.1">
                        </div>
                        <div class="parameter-row" id="min-radius-row">
                          <label class="parameter-label">Minimum radius</label>
                          <input type="number" id="treeloc-min-rad" class="parameter-input" value="0.2" min="0.0" step="0.1">
                        </div>
                      </div>
                      <div class="tooltip">
                        <button id="rerun-loc-extraction" class="sub-option">Re-run extraction</button>
                        <span class="tooltiptext">Re-run tree location extraction based on the DL confidence and radius prediction</span>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Module 3: TreeOff -->
                <div class="module-box" id="treeoff-module">
                  <div class="module-title">
                    <input type="radio" id="module-treeoff" name="module">
                    <label class="module-title-text" for="module-treeoff">3. TreeOff</label>
                  </div>
                  <div class="module-content">
                    <!-- TreeOff and ShortestPath share parameters -->
                  </div>
                </div>

                <!-- Module 3 alt: ShortestPath -->
                <div class="module-box" id="sp-module">
                  <div class="module-title">
                    <input type="radio" id="module-sp" name="module">
                    <label class="module-title-text" for="module-sp">3. StemClusterSP</label>
                  </div>
                  <div class="module-content">
                    <div class="parameter-pair sub-option">
                      <div class="parameter-row">
                        <label class="parameter-label">Resolution(m)</label>
                        <input type="number" id="sp-resolution" class="parameter-input" value="0.06" min="0.01" step="0.01">
                      </div>
                      <div class="parameter-row">
                        <label class="parameter-label">Max gap(m)</label>
                        <input type="number" id="sp-max-gap" class="parameter-input" value="0.3" min="0.1" step="0.1">
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Module 4: CrownOff3D -->
                <div class="module-box" id="crownoff-module">
                  <div class="module-title">
                    <input type="radio" id="module-crownoff" name="module">
                    <label class="module-title-text" for="module-crownoff">4. CrownOff3D</label>
                  </div>
                  <div class="module-content">
                    <!-- No parameters for CrownOff3D -->
                  </div>
                </div>

                <!-- Module 4 alt: TreeisoSP -->
                <div class="module-box" id="treeisosp-module">
                  <div class="module-title">
                    <input type="radio" id="module-treeisosp" name="module">
                    <label class="module-title-text" for="module-treeisosp">4. CrownClusterSP (treeiso+SP)</label>
                  </div>
                  <div class="module-content">
                    <div class="parameter-pair sub-option">
                      <div class="parameter-row">
                        <label class="parameter-label">Resolution</label>
                        <input type="number" id="treeisosp-resolution" class="parameter-input" value="0.15" min="0.01" step="0.01">
                      </div>
                      <div class="parameter-row">
                        <label class="parameter-label">Nearest K</label>
                        <input type="number" id="treeisosp-k" class="parameter-input" value="5" min="5" step="1">
                      </div>
                    </div>
                    <div class="parameter-pair sub-option">
                      <div class="parameter-row">
                        <label class="parameter-label">Strength</label>
                        <input type="number" id="treeisosp-lambda" class="parameter-input" value="1.0" min="0.01" step="0.01">
                      </div>
                      <div class="parameter-row">
                        <label class="parameter-label">Max gap(m)</label>
                        <input type="number" id="treeisosp-max-gap" class="parameter-input" value="0.4" min="0.1" step="0.1">
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </details>

          <div class="select-option">
            <div class="select-model-container">
              <div class="select-option-title" style="font-size:14px">Predefined models</div>
              <select id="pretrain-treeisonet" style="font-size:14px">
                <!-- Models will be populated dynamically -->
              </select>
            </div>
            <div class="button-container">
              <div class="button-row">
                <div class="tooltip">
                    <button class="model-path-btn">Model path</button>
                    <span class="tooltiptext">Open the folder with downloaded models</span>
                </div>
                <div class="tooltip">
                    <button class="download-btn">Download</button>
                    <span class="tooltiptext">Download the pre-trained model</span>
                </div>
              </div>
            </div>
          </div>

          <button class="full-width-button" id="treeisonet-apply-btn">Apply</button>
          <details class="option-group" open>
            <summary class="option-group-title" style="height:12px;padding:5px">Export</summary>
            <div class="option-group-content" style="padding:0;margin:5px 0px 0px 5px">
              <div class="input-groups-row" style="padding:0;margin:0">
                <div class="input-group">
                  <label for="treestat-resolution">DTM resolution (m)</label>
                  <input type="number" id="treestat-resolution" value="1.0" min="0.1" step="0.1">
                </div>
                <div class="input-group">
                  <div class="tooltip">
                      <button id="treeisonet-export-btn">Export stats</button>
                      <span class="tooltiptext">Export the tree height and area statistics to csv based on the tree segments</span>
                  </div>
                  <button class="open-output-btn">Open output path</button>
                </div>
              </div>
            </div>
          </details>


        </div>
      </div>
    </div>

    <!-- WoodCls Tab Content -->
    <div class="tab-content" id="woodcls-content">
      <div class="section-title">Wood filtering from TLS</div>

      <div class="content-row">
        <div class="image-container" style="width:40%">
          <img class="resizable-image" src="img/woodcls_branch.jpg" alt="WoodCls Branch Image">
        </div>
        <div class="handle"></div>
        <div class="controls-container">
          <div class="reference-box">
            <div class="tooltip">
              <button class="copy-btn">📄</button>
              <span class="tooltiptext">Copy reference to clipboard</span>
            </div>
            <span class="copy-tooltip">Copied!</span>
            Please reference the publication if you find this tool helpful:
            <br><br>
            Xi, Zhouxin, Chris Hopkinson, and Laura Chasmer."Filtering stems and branches from terrestrial laser scanning point clouds using deep 3-D fully convolutional networks." <i>Remote Sensing</i> 10.8 (2018): 1215.
            <br>
            <a href="https://doi.org/10.3390/rs10081215" class="external-link">https://doi.org/10.3390/rs10081215</a>
            <br><br>
            Xi, Zhouxin, Laura Chasmer, and Chris Hopkinson. "Delineating and Reconstructing 3D Forest Fuel Components and Volumes with Terrestrial Laser Scanning." <i>Remote Sensing</i> 15.19 (2023): 4778.
            <br>
            <a href="https://doi.org/10.3390/rs15194778" class="external-link">https://doi.org/10.3390/rs15194778</a>
          </div>

          <details class="option-group" open>
            <summary class="option-group-title">Sensor</summary>
            <div class="option-group-content">
              <div class="radio-option">
                <input type="radio" id="tls-sensor" checked>
                <label for="tls-sensor">TLS</label>
              </div>
            </div>
          </details>

          <details class="option-group" open>
            <summary class="option-group-title">Component</summary>
            <div class="option-group-content">
              <div class="radio-option">
                <input type="radio" id="stem-component" name="component">
                <label for="stem-component">Stem</label>
              </div>
              <div class="radio-option">
                <input type="radio" id="branch-component" name="component" checked>
                <label for="branch-component">Branch</label>
              </div>
            </div>
          </details>

          <div class="select-option">
            <div class="select-model-container">
              <div class="select-option-title">Predefined models</div>
              <select id="pretrain-woodcls">
                <!-- Models will be populated dynamically -->
              </select>
            </div>
            <div class="button-container">
              <div class="button-row">
                <div class="tooltip">
                    <button class="model-path-btn">Model path</button>
                    <span class="tooltiptext">Open the folder with downloaded models</span>
                </div>
                <div class="tooltip">
                    <button class="download-btn">Download</button>
                    <span class="tooltiptext">Download the pre-trained model</span>
                </div>
              </div>
            </div>
          </div>

          <button class="full-width-button apply-btn">Apply</button>
<!--          <div class="tooltip" style="margin-top: 5px; text-align: center;">-->
<!--            <span>Need help?</span>-->
<!--            <span class="tooltiptext">⚠️ The selected point cloud in CloudCompare will be processed with the chosen model</span>-->
<!--          </div>-->
        </div>
      </div>
    </div>

    <!-- QSM Tab Content -->
    <div class="tab-content" id="qsm-content">
      <div class="section-title">Plot-level quantitative structural modeling</div>

      <div class="content-row">
        <div class="image-container" style="width:40%">
          <img class="resizable-image" src="img/branchreconstruction.jpg" alt="Branch Reconstruction Image">
        </div>
        <div class="handle"></div>
        <div class="controls-container">
          <div class="reference-box">
            <div class="tooltip">
              <button class="copy-btn">📄</button>
              <span class="tooltiptext">Copy reference to clipboard</span>
            </div>
            <span class="copy-tooltip">Copied!</span>
            Please reference the publication if you find this tool helpful:
            <br><br>
            Xi, Zhouxin, Laura Chasmer, and Chris Hopkinson. "Delineating and Reconstructing 3D Forest Fuel Components and Volumes with Terrestrial Laser Scanning." <i>Remote Sensing</i> 15.19 (2023): 4778.
            <br>
            <a href="https://doi.org/10.3390/rs15194778" class="external-link">https://doi.org/10.3390/rs15194778</a>
          </div>

          <div class="warning-box">
            Please ensure the selected point cloud(s) have a scalar field of "stemcls" identifying the stem class. This can be obtained by from the TreeisoNet or WoodCls tab. You can also provide the "branchcls" scalar field (optional) indicating the branch classes.
          </div>

          <details class="option-group" open>
            <summary class="option-group-title">Initial segmentation: cut-pursuit</summary>
            <div class="option-group-content">
              <div class="input-groups-row">
                <div class="input-group">
                  <label for="stem-k">Stem: Nearest K</label>
                  <input type="number" id="stem-k" value="20" min="3" max="100">
                </div>
                <div class="input-group">
                  <label for="stem-strength">Strength</label>
                  <input type="number" id="stem-strength" value="1" min="0.01" max="100" step="0.5">
                </div>
              </div>
              <div class="input-groups-row">
                <div class="input-group">
                  <label for="branch-k">Branch: Nearest K</label>
                  <input type="number" id="branch-k" value="4" min="3" max="100">
                </div>
                <div class="input-group">
                  <label for="branch-strength">Strength</label>
                  <input type="number" id="branch-strength" value="0.1" min="0.01" max="100" step="0.5">
                </div>
              </div>
              <button class="full-width-button" id="init-segmentation-btn">Initial segmentation</button>
            </div>
          </details>

          <details class="option-group" open>
            <summary class="option-group-title">Skeletonization</summary>
            <div class="option-group-content">
              <div class="input-groups-row">
                <div class="input-group">
                  <label for="gap-connectivity">Gap defining connectivity(m)</label>
                  <input type="number" id="gap-connectivity" value="0.03" min="0" max="10" step="0.01">
                </div>
                <div class="input-group">
                  <label for="max-gap">Max gap cutoff (m)</label>
                  <input type="number" id="max-gap" value="0.4" min="0" max="10" step="0.1">
                </div>
              </div>
              <button class="full-width-button" id="skeletonization-btn">Skeletonization and Export</button>
              <button class="full-width-button open-output-btn">Open output path (tree structure as xml)</button>
            </div>
          </details>
        </div>
      </div>
    </div>

    <div class="tab-content" id="about-content">
    <div class="section-title">About TreeAIBox</div>

    <div class="content-row">
      <div class="image-container" style="width: 30%; border:None">
        <img class="resizable-image" src="img/logo_wall.png" alt="Logos of Contributing Organizations" style="border: 1px solid #ddd;">
        <div class="image-caption">TreeAIBox is a collaborative initiative bringing together expertise from various institutions</div>
      </div>
      <div class="handle"></div>
      <div class="controls-container">
        <div class="reference-box">
          <div class="about-box-title">About Us</div>
          <p><strong>Developer:</strong> Zhouxin Xi, Canadian Forest Service, Natural Resources Canada</p>
          <p><strong>Supervision and support:</strong></p>
          <p><strong>TreeFiltering/WoodCls/QSM:</strong> Chris Hopkinson and Laura Chasmer, ARTEMIS / PEATERS Laboratory, i4Geo, University of Lethbridge</p>
          <p><strong>TreeisoNet:</strong> Dani Degenhardt, Canadian Forest Service, Natural Resources Canada</p>
        </div>

        <div class="reference-box">
          <div class="about-box-title">Data Credit</div>
          <p>Training reference dataset were manually cleaned, originated from:</p>
          <ul>
            <li><strong>TLS:</strong> <a href="https://doi.org/10.20383/103.0814" class="external-link">Jasper National Park plot scans</a> collected by University of Lethbridge</li>
            <li><strong>TLS:</strong> <a href="https://doi.org/10.20383/103.0814" class="external-link"> Plot scans</a> collected by University of Lethbridge and during 2014-2020 and <a href="https://laserscanning.fi/results-available-for-international-benchmarking-of-terrestrial-laser-scanning-methods/" class="external-link"> scans</a> by Finnish Geodetic Institute during 2014</li>
            <li><strong>ALS:</strong> Eastern Slopes of Alberta scans collected by University of Lethbridge</li>
            <li><strong>UAV:</strong> Reclamation UAV drone scans collected by Natural Resources Canada</li>
            <li><strong>UAV:</strong> <a href="https://doi.org/10.5281/zenodo.8287792" class="external-link">FOR-instance dataset</a> from Puliti S, Pearse G, Surový P, et al.(2023).</li>
          </ul>
        </div>

<!--        <div class="reference-box">-->
<!--          <div class="about-box-title">Citation</div>-->
<!--          <p>If you use TreeAIBox in your research, please cite the relevant publications:</p>-->
<!--          <ul>-->
<!--            <li>Xi, Z., Hopkinson, C., & Chasmer, L. (2024). Supervised terrestrial to airborne laser scanner model calibration for 3D individual-tree attribute mapping using deep neural networks. <em>ISPRS Journal of Photogrammetry and Remote Sensing</em>, 209, 324-343.</li>-->
<!--            <li>Xi, Z., & Degenhardt, D. (2025). A new unified framework for supervised 3D crown segmentation (TreeisoNet) using deep neural networks across airborne, UAV-borne, and terrestrial laser scans. <em>ISPRS Open Journal of Photogrammetry and Remote Sensing</em>, 15, 100083.</li>-->
<!--            <li>Xi, Z., Hopkinson, C., & Chasmer, L. (2018). Filtering stems and branches from terrestrial laser scanning point clouds using deep 3-D fully convolutional networks. <em>Remote Sensing</em>, 10(8), 1215.</li>-->
<!--            <li>Xi, Z., Chasmer, L., & Hopkinson, C. (2023). Delineating and Reconstructing 3D Forest Fuel Components and Volumes with Terrestrial Laser Scanning. <em>Remote Sensing</em>, 15(19), 4778.</li>-->
<!--          </ul>-->
<!--        </div>-->
      </div>
    </div>
  </div>

    <!-- Notification area -->
    <div id="notification" class="notification">
      <span id="notification-message"></span>
    </div>
    <!-- Progress bar -->
    <div class="progress-bar">
      <div class="progress" id="progress-indicator"></div>
    </div>
  </div>

  <!-- Script section -->
  <script>
    // Global variables
    let backend;
    // let currentTab = 'treefiltering';
    let currentTab = 'treeisonet';
    let models = [];
    let modelsStatus = {};

    // Initialize the application when the document is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Set up the Qt Web Channel
        new QWebChannel(qt.webChannelTransport, function(channel) {
            // Get the backend object
            backend = channel.objects.backend;

            // Connect signals from Python to JavaScript
            backend.progressUpdated.connect(updateProgressBar);
            backend.showNotification.connect(showNotification);
            backend.updateModelList.connect(updateModelList);

            // Initialize UI
            initializeTabs();
            initializeGPUOption();
            initializeButtons();
            initializeTreeisoNet();
            initializeCopyButtons();

            initializeResizablePanels();

            setupExternalLinks();
            setupHeaderLinks();



            // Load the model list
            loadModelList();
        });
    });

    // Initialize tab switching
    function initializeTabs() {
        const tabs = document.querySelectorAll('.tab');

        tabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs
                tabs.forEach(t => t.classList.remove('active'));

                // Add active class to clicked tab
                this.classList.add('active');

                // Hide all tab contents
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });

                // Show the selected tab content
                const tabName = this.getAttribute('data-tab');
                currentTab = tabName;
                document.getElementById(tabName + '-content').classList.add('active');

                // Reset progress bar
                updateProgressBar(0);
                // Refresh model select dropdown for the current tab
                populateModelSelect();
            });
        });
    }

    // Initialize GPU checkbox
    function initializeGPUOption() {
        const gpuCheckbox = document.getElementById('use-gpu');

        // Check if CUDA is available
        backend.isCudaAvailable().then(available => {
            if (available) {
                gpuCheckbox.checked = true;
            } else {
                gpuCheckbox.checked = false;
                gpuCheckbox.disabled = true;
                showNotification("GPU (CUDA) is not available. Using CPU instead.", "info");
            }
        });
    }

    // Initialize button click events
    function initializeButtons() {
        // WoodCls tab buttons
        let model_path_btns=document.getElementsByClassName('model-path-btn');
        for (let model_path_btn of model_path_btns){
            model_path_btn.addEventListener('click', function() {
            backend.openDirectory('model');
        })}

        let download_btns=document.getElementsByClassName('download-btn');
        for (let download_btn of download_btns) {
          download_btn.addEventListener('click', function () {
            const select = document.getElementById("pretrain-" + currentTab);
            const selectedModel = select.options[select.selectedIndex].value;

            if (selectedModel) {
              updateProgressBar(0);
              backend.downloadModel(selectedModel).then(success => {
                if (success) {
                  // Refresh model list to update the UI
                  loadModelList();
                }
              });
            } else {
              showNotification("Please select a model to download", "warning");
            }
          });
        }

        document.querySelectorAll('.apply-btn').forEach(button => {
          button.addEventListener('click', function() {
            const useGPU = document.getElementById('use-gpu').checked;
            const isALS = document.getElementById('filter-als-sensor').checked;

            let componentType = "treefilter";
            if (currentTab!=="treefiltering"){
              componentType = document.getElementById('stem-component').checked ? 'stemcls' : 'branchcls';
            }
            const select = document.getElementById('pretrain-'+currentTab);

            // showNotification(select.textContent, "warning");
            // Check if there are any options and if an option is selected
            if (select.options.length === 0 || select.selectedIndex === -1) {
                showNotification("Please select a model first", "warning");
                return;
            }

            const selectedModel = select.options[select.selectedIndex].value;

            // Double-check that we have a valid model name
            if (!selectedModel || selectedModel === "No models available") {
                showNotification("Please select a valid model", "warning");
                return;
            }
            console.log("Selected model: " + selectedModel);

            // First, tell Python which model is selected
            backend.getSelectedModel(selectedModel).then(model => {
                // Then apply WoodCls
                updateProgressBar(5);
                backend.compFilter(useGPU, componentType,componentType==="treefilter" && (!isALS),"filter").then(success => {
                    // if (!success) {
                    //     showNotification("Failed to apply " + componentType + " filtering", "error");
                    // }
                });
            });
          });
        });

        document.getElementById('treeisonet-apply-btn').addEventListener('click', function() {
            const useGPU = document.getElementById('use-gpu').checked;

            // Get the selected module
            const moduleElement = document.querySelector('input[name="module"]:checked');
            if (!moduleElement) {
                showNotification("Please select a module", "warning");
                return;
            }

            const moduleId = moduleElement.id;
            let module = moduleId.replace('module-', '');

            if (module === 'sp') {
              const resolution = parseFloat(document.getElementById('sp-resolution').value);
              const maxGap = parseFloat(document.getElementById('sp-max-gap').value);
              backend.stemClusterSP(resolution, maxGap).then(success => {
                if (!success) {
                  // showNotification(`Failed to apply TreeisoNet ${module}`, "error");
                }
              });
              return;
            }else if (module === 'treeisosp') {
              const resolution = parseFloat(document.getElementById('treeisosp-resolution').value);
              const k = parseInt(document.getElementById('treeisosp-k').value);
              const lambda = parseFloat(document.getElementById('treeisosp-lambda').value);
              const maxGap = parseFloat(document.getElementById('treeisosp-max-gap').value);

              backend.crownClusterSP(resolution, k, lambda, maxGap).then(success => {
                // if (!success) {
                //   showNotification(`Failed to apply TreeisoNet ${module}`, "error");
                // }
              });
              return;
            }

            const select = document.getElementById('pretrain-treeisonet');

            // Check if there are any options and if an option is selected
            if (select.options.length === 0 || select.selectedIndex === -1) {
                showNotification("Please select a model first", "warning");
                return;
            }

            const selectedModel = select.options[select.selectedIndex].value;

            // Double-check that we have a valid model name
            if (!selectedModel || selectedModel === "No models available") {
                showNotification("Please select a valid model", "warning");
                return;
            }

            // Tell Python which model is selected
            backend.getSelectedModel(selectedModel).then(model => {
                updateProgressBar(0);

                // Get module specific parameters
                if (module === 'stemcls') {
                    // No additional parameters needed
                    updateProgressBar(5);
                    backend.compFilter(useGPU, "stemcls",false,"treeisonet").then(success => {
                        if (!success) {
                            // showNotification("Failed to apply stemcls", "error");
                        }
                    });

                } else if (module === 'treeloc') {
                    const conf_thresh = parseFloat(document.getElementById('treeloc-conf-thresh').value);
                    const nms_thresh = parseFloat(document.getElementById('treeloc-nms-thresh').value);
                    const max_gap = parseFloat(document.getElementById('treeloc-max-gap').value);
                    const min_rad = parseFloat(document.getElementById('treeloc-min-rad').value);
                    const cutoff_thresh = parseFloat(document.getElementById('treeloc-cutoff').value);

                    if_stem=model.includes("tls") || model.includes("uav");
                    // showNotification(`TreeisoNet ${conf_thresh} ${nms_thresh} ${max_gap} ${min_rad}`, "error");
                    // Call the appropriate backend function based on the module
                    backend.treeLoc(useGPU, if_stem, cutoff_thresh, conf_thresh, min_rad, max_gap, nms_thresh).then(success => {
                        // if (!success) {
                        //     showNotification(`Failed to apply TreeisoNet ${module}`, "error");
                        // }
                    });

                } else if (module === 'treeoff') {
                    backend.treeOff(useGPU).then(success => {
                        // if (!success) {
                        //     showNotification(`Failed to apply TreeisoNet ${module}`, "error");
                        // }
                    });
                } else if (module === 'crownoff') {
                    // No additional parameters needed
                    backend.crownOff(useGPU).then(success => {
                        // if (!success) {
                        //     showNotification(`Failed to apply TreeisoNet ${module}`, "error");
                        // }
                    });
                }

            });
        });

        const radioButtons = document.querySelectorAll('input[type="radio"][name="module"]');

        radioButtons.forEach(radio => {
          radio.addEventListener('change', function() {
            const selectId = "pretrain-" + currentTab;
            if (!selectId) return;
            const select = document.getElementById(selectId);
            // Get references to the specific radio buttons
            const moduleSp = document.getElementById('module-sp');
            const moduleTreeisosp = document.getElementById('module-treeisosp');

            // Check if either of the specified radio buttons is checked
            if ((moduleSp && moduleSp.checked) || (moduleTreeisosp && moduleTreeisosp.checked)) {
              select.parentElement.classList.add('disabled');
            } else {
              select.parentElement.classList.remove('disabled');
            }
          });
        });


        // TreeisoNet noise clean button
        document.getElementById('noise-clean-btn').addEventListener('click', function() {
            const maxGap = parseFloat(document.getElementById('clean-max-gap').value);
            const minPoints = parseInt(document.getElementById('clean-min-points').value);

            backend.applyNoiseClean(maxGap, minPoints).then(success => {
                if (!success) {
                    // showNotification("Failed to clean small clusters", "error");
                }
            });
        });

        // QSM tab buttons
        document.getElementById('init-segmentation-btn').addEventListener('click', function() {
            const stemK = parseInt(document.getElementById('stem-k').value);
            const stemStrength = parseFloat(document.getElementById('stem-strength').value);
            const branchK = parseInt(document.getElementById('branch-k').value);
            const branchStrength = parseFloat(document.getElementById('branch-strength').value);

            updateProgressBar(0);
            backend.applyQSMInitSegmentation(stemK, stemStrength, branchK, branchStrength).then(success => {
                if (!success) {
                    // showNotification("Failed to apply initial segmentation", "error");
                }
            });
        });

        document.getElementById('skeletonization-btn').addEventListener('click', function() {
            const gapConnectivity = parseFloat(document.getElementById('gap-connectivity').value);
            const maxGap = parseFloat(document.getElementById('max-gap').value);

            updateProgressBar(0);
            backend.applyQSM(gapConnectivity, maxGap).then(success => {
                if (!success) {
                    // showNotification("Failed to apply QSM", "error");
                }
            });
        });

        let output_path_btns=document.getElementsByClassName('open-output-btn');
        for (let output_path_btn of output_path_btns){
            output_path_btn.addEventListener('click', function() {
            backend.openDirectory('log');
        })}
    }

// Initialize resizable panels
function initializeResizablePanels() {
  const handles = document.querySelectorAll('.handle');

  handles.forEach(handle => {
    handle.addEventListener('mousedown', function(e) {
      e.preventDefault();

      // Get the parent container and the image container
      const contentRow = handle.parentElement;
      const imageContainer = contentRow.querySelector('.image-container');

      // Store initial positions and dimensions
      const startX = e.clientX;
      const startWidth = imageContainer.offsetWidth;

      // Function to handle mouse movement
      function onMouseMove(e) {
        // Calculate new width based on mouse movement
        const deltaX = e.clientX - startX;
        const newWidth = Math.max(200, Math.min(contentRow.offsetWidth - 300, startWidth + deltaX));

        // Apply new width only to the image container
        // Controls container will automatically flex to fill remaining space
        imageContainer.style.width = `${newWidth}px`;

        // Log for debugging
        console.log(`Resizing: imageWidth=${newWidth}px`);
      }

      // Function to clean up event listeners
      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        handle.classList.remove('active');
      }

      // Add active class to the handle
      handle.classList.add('active');

      // Add event listeners for drag operation
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  });
}




// Initialize TreeisoNet specific interactions
    function initializeTreeisoNet() {
        // Scene "Any" checkbox behavior
        document.querySelectorAll('input[name="scene"], input[name="sensor"], input[name="filter-sensor"], input[name="module"]')
        .forEach(radio => {
          radio.addEventListener('change', function() {
            if (this.checked) {
              // For all radio buttons, handle module-specific UI updates
              // showNotification(this.id,"error");
              if (this.name!=="scene"){
                toggleModuleSpecificUI(this.id);
              }
              // Handle image updates based on the radio ID
              if (this.id === 'sensor-tls') {
                document.getElementById('treeisonet-image').src = 'img/treeisonet_tls.jpg';
                toggleALSSpecificUI(false);
              } else if (this.id === 'sensor-uav') {
                document.getElementById('treeisonet-image').src = 'img/treeisonet_uav.jpg';
                toggleALSSpecificUI(false);
              } else if (this.id === 'sensor-als') {
                document.getElementById('treeisonet-image').src = 'img/treeisonet_als.jpg';
                toggleALSSpecificUI(true);
                // toggleModuleSpecificUI('');
              } else if (this.id === 'filter-tls-sensor') {
                document.getElementById('treefilter-image').src = 'img/treefiltering_tls.jpg';
                toggleALSSpecificUI(true);
              } else if (this.id === 'filter-uav-sensor') {
                document.getElementById('treeisonet-image').src = 'img/treefiltering_uav.jpg';
                toggleALSSpecificUI(true);
              } else if (this.id === 'filter-als-sensor') {
                document.getElementById('treeisonet-image').src = 'img/treefiltering_als.jpg';
                toggleALSSpecificUI(true);
              }

              // Always call populateModelSelect after any radio change
              populateModelSelect();
            }
          });
        });

        document.getElementById('scene-any').addEventListener('change', function() {
          if (this.checked) {
            document.getElementById('treeisonet-image').src = 'img/treeisonet_any.jpg';
            // toggleALSSpecificUI(false);
          }
          populateModelSelect();

        });

        // // Initialize the UI based on default selections
        toggleModuleSpecificUI('module-stemcls');
        document.getElementById('treeoff-module').classList.add('disabled');
    }

    // Toggle ALS specific UI elements
    function toggleALSSpecificUI(isALS) {
        if (isALS) {
            // When ALS is selected, force TreeLoc for the first module
            document.getElementById('module-treeloc').checked = true;
            toggleModuleSpecificUI('module-treeloc');

            // Disable modules that are not suitable for ALS
            document.getElementById('stemcls-module').classList.add('disabled');
            document.getElementById('treeisosp-module').classList.add('disabled');
            document.getElementById('crownoff-module').classList.add('disabled');
            document.getElementById('sp-module').classList.add('disabled');

            // Enable modules suitable for ALS
            document.getElementById('treeoff-module').classList.remove('disabled');
            document.getElementById('treeloc-default-content').style.display = 'block';
            document.getElementById('treeloc-cutoff-content').style.display = 'none';

        } else {
            // Reset all modules to be enabled

            document.getElementById('treeloc-default-content').style.display = 'none';
            document.getElementById('treeloc-cutoff-content').style.display = 'block';

            document.getElementById('stemcls-module').classList.remove('disabled');
            document.getElementById('treeisosp-module').classList.remove('disabled');
            document.getElementById('crownoff-module').classList.remove('disabled');
            document.getElementById('sp-module').classList.remove('disabled');

            document.getElementById('module-stemcls').checked = true;
            toggleModuleSpecificUI('module-stemcls');
            document.getElementById('treeoff-module').classList.add('disabled');
        }
    }

    // Toggle UI elements specific to each module
    function toggleModuleSpecificUI(moduleId) {

        // Hide all module-specific parameters
        document.querySelectorAll('.module-content').forEach(content => {
            content.style.display = 'none';
        });
        // showNotification(moduleId,"error")

        // Show the selected module's parameters
        if (moduleId === 'module-stemcls') {
            document.querySelector('#stemcls-module .module-content').style.display = 'block';
        } else if (moduleId === 'module-sp') {
            document.querySelector('#sp-module .module-content').style.display = 'block';
        } else if (moduleId === 'module-treeisosp') {
            document.querySelector('#treeisosp-module .module-content').style.display = 'block';
        }else if (moduleId === 'module-treeloc') {
            document.querySelector('#treeloc-module .module-content').style.display = 'block';
        }
    }

    // Load model list from Python backend
    function loadModelList() {
        console.log("Requesting model list from Python backend");
        backend.getModelList().then(result => {
            console.log("Received model list:", result);
            try {
                const data = JSON.parse(result);
                models = data.models || [];
                modelsStatus = data.status || {};

                console.log("Parsed models:", models);
                console.log("Parsed status:", modelsStatus);

                populateModelSelect();
            } catch (e) {
                console.error("Error parsing model list:", e);
                showNotification("Error loading model list: " + e.message, "error");
            }
        }).catch(err => {
            console.error("Error getting model list:", err);
            showNotification("Failed to load model list", "error");
        });
    }

    // Update model list when signal received from Python
    function updateModelList(modelsJson) {
        const data = JSON.parse(modelsJson);
        models = data.models;
        modelsStatus = data.status;
        populateModelSelect();
    }

    // Populate the model select dropdown
    function populateModelSelect() {
        // Choose the appropriate select element based on the current tab
        const selectId = "pretrain-"+currentTab;
        if (!selectId) return;

        const select = document.getElementById(selectId);

        select.innerHTML = '';

        // Filter models based on current tab and component/sensor/scene selections
        const filteredModels = filterModelsByCurrentSettings();

        console.log(`Available models for ${currentTab}:`, filteredModels);

        // showNotification(filteredModels, "error");

        if (filteredModels.length === 0) {
            const option = document.createElement('option');
            option.text = "No models available";
            option.disabled = true;
            select.add(option);
            console.log(`No models available for the current ${currentTab} settings`);
        } else {
            filteredModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.text = model;

                // Style downloaded models differently
                if (modelsStatus[model]) {
                    option.className = 'downloaded';
                    console.log("Model downloaded: " + model);
                } else {
                    option.className = 'not-downloaded';
                    console.log("Model not downloaded: " + model);
                }

                select.add(option);
            });
            // Select the first option by default
            select.selectedIndex = 0;
            console.log(`Default selected ${currentTab} model: ${select.options[0].value}`);
        }
    }

    // Filter models based on current tab and selections
    function filterModelsByCurrentSettings() {
        let keywords = [currentTab];

        if (currentTab === 'woodcls') {
          if (document.getElementById('stem-component').checked) {
            keywords.push('stem');
          } else if (document.getElementById('branch-component').checked) {
            keywords.push('branch');
          }
          if (document.getElementById('tls-sensor').checked) {
              keywords.push('tls');
          }

        } else if (currentTab === 'treeisonet') {
            // Add sensor
            if (document.getElementById('sensor-tls').checked) {
                keywords.push('tls');
            } else if (document.getElementById('sensor-uav').checked) {
                keywords.push('uav');
            } else if (document.getElementById('sensor-als').checked) {
                keywords.push('als');
            }

            // Add scene if "Any" is not checked
            if (!document.getElementById('scene-any').checked) {
                if (document.getElementById('scene-boreal').checked) {
                    keywords.push('boreal');
                } else if (document.getElementById('scene-mixedwood').checked) {
                    keywords.push('mixedwood');
                } else if (document.getElementById('scene-reclamation').checked) {
                    keywords.push('reclamation');
                }
            }
            // Add module
            const moduleElement = document.querySelector('input[name="module"]:checked');
            if (moduleElement) {
                const moduleId = moduleElement.id;
                const module = moduleId.replace('module-', '');
                keywords.push(module);
            }
        }else if (currentTab === 'treefiltering') {
            // Add sensor
            if (document.getElementById('filter-tls-sensor').checked) {
                keywords.push('tls');
            } else if (document.getElementById('filter-uav-sensor').checked) {
                keywords.push('uav');
            } else if (document.getElementById('filter-als-sensor').checked) {
                keywords.push('als');
            }
        }
        console.log("Filtering models with keywords:", keywords);

        //showNotification(models, "error");

        // Filter models that match all keywords
        const filtered = models.filter(model =>
            keywords.every(keyword =>
                model.toLowerCase().includes(keyword.toLowerCase())
            )
        );

        if (filtered.length === 0) {
            console.log("No models match specific keywords.");
        }

        return filtered;
    }

    // Update progress bar
    function updateProgressBar(percent) {
        document.getElementById('progress-indicator').style.width = percent + '%';
    }

    // Show notification
    function showNotification(message, type) {
        const notification = document.getElementById('notification');
        const messageElement = document.getElementById('notification-message');

        // Set message
        messageElement.textContent = message;

        // Remove all classes
        notification.className = 'notification';

        // Add appropriate class based on type
        notification.classList.add(type);

        // Show notification
        notification.style.display = 'block';

        // Hide after 5 seconds
        setTimeout(function() {
            notification.style.display = 'none';
        }, 15000);
    }

    // Event listeners for component radio buttons to update model list
    document.querySelectorAll('input[name="component"]').forEach(radio => {
        radio.addEventListener('change', function() {
            populateModelSelect();

            // Update displayed image
            if (this.id === 'stem-component') {
                document.querySelector('#woodcls-content .resizable-image').src = 'img/woodcls_stem.jpg';
            } else {
                document.querySelector('#woodcls-content .resizable-image').src = 'img/woodcls_branch.jpg';
            }
        });
    });


    document.getElementById('create-dtm-btn').addEventListener('click', function() {
      const tileEnable = document.getElementById('tile-enable').checked;
      const tileSize = parseFloat(document.getElementById('dtm-tile-size').value);
      const bufferSize = parseFloat(document.getElementById('dtm-buffer-size').value);
      const resolution = parseFloat(document.getElementById('dtm-resolution').value);

      updateProgressBar(5);
      backend.createDTM(tileEnable, tileSize, bufferSize, resolution).then(success => {
        if (!success) {
          // showNotification("Failed to create DTM", "error");
        }
      });
    });


    // TreeisoNet noise clean button
    document.getElementById('rerun-loc-extraction').addEventListener('click', function() {
        const confThresh = parseFloat(document.getElementById('treeloc-conf-thresh').value);
        const nmsThresh = parseFloat(document.getElementById('treeloc-nms-thresh').value);
        const maxGap = parseFloat(document.getElementById('treeloc-max-gap').value);
        const minRad = parseFloat(document.getElementById('treeloc-min-rad').value);

        updateProgressBar(5);

        // showNotification(`TreeisoNet ${conf_thresh} ${nms_thresh} ${max_gap} ${min_rad}`, "error");
        // showNotification(maxGap, "error");
        backend.postRefineTreeLoc(confThresh,minRad,maxGap,nmsThresh).then(success => {
            // if (!success) {
            //     showNotification("Failed to refine tree loations", "error");
            // }
        });
    });

    document.getElementById('treeisonet-export-btn').addEventListener('click', function() {
      const resolution = parseFloat(document.getElementById('treestat-resolution').value);

      updateProgressBar(0);
      backend.treeStat(resolution).then(success => {
        if (!success) {
          // showNotification("Failed to export stats", "error");
        }
      });
    });

    // Function to copy reference text
// Function to copy reference text
function copyReferenceText(event) {
  // Get the parent reference box (adjusted to account for tooltip wrapper)
  const referenceBox = event.target.closest('.tooltip').parentElement;

  // Find all <br> elements
  const brs = referenceBox.querySelectorAll('br');

  // If we have at least 2 <br> elements, find the content after the second <br>
  let textToCopy = '';

  if (brs.length >= 2) {
    // Get the node after the second <br>
    let currentNode = brs[1].nextSibling;

    // Collect text but stop when we reach the <br> before the link
    while (currentNode) {
      // Stop collecting text once we reach the <br> that comes before a link
      if (currentNode.nodeType === Node.ELEMENT_NODE &&
          currentNode.tagName === 'BR' &&
          currentNode.nextSibling &&
          currentNode.nextSibling.nodeType === Node.ELEMENT_NODE &&
          currentNode.nextSibling.tagName === 'A') {
        break;
      }

      // Otherwise collect text content
      if (currentNode.nodeType === Node.TEXT_NODE) {
        textToCopy += currentNode.textContent;
      } else if (currentNode.nodeType === Node.ELEMENT_NODE &&
                !currentNode.classList.contains('tooltip') &&
                !currentNode.classList.contains('copy-tooltip') &&
                currentNode.tagName !== 'A') {
        textToCopy += currentNode.textContent;
      }

      currentNode = currentNode.nextSibling;
    }
  }

  // Clean up the text (remove extra spaces, etc.)
  textToCopy = textToCopy.replace(/\s+/g, ' ').trim();

  // Use the backend object to copy to clipboard
  backend.copyToClipboard(textToCopy).then(success => {
    if (success) {
      // Show the copied tooltip
      const copyTooltip = referenceBox.querySelector('.copy-tooltip');
      copyTooltip.classList.add('show');

      // Remove the show class after animation completes
      setTimeout(() => {
        copyTooltip.classList.remove('show');
      }, 2000);
    }
  });

  // Prevent the event from bubbling up
  event.stopPropagation();
}

function setupHeaderLinks() {
  document.querySelector('.github-link').addEventListener('click', function(event) {
    event.preventDefault();
    backend.openExternalLink('https://github.com/truebelief/cc-TreeAIBox-plugin');
  });

  // document.querySelector('.homepage-link').addEventListener('click', function(event) {
  //   event.preventDefault();
  //   backend.openExternalLink('http://xizhouxin.com/');
  // })
}

// Function to handle external links
function setupExternalLinks() {
  document.querySelectorAll('.reference-box a').forEach(link => {
    link.addEventListener('click', function(event) {
      event.preventDefault(); // Prevent default link behavior
      const url = this.getAttribute('href');
      backend.openExternalLink(url); // Call Python function to open browser
    });
  });
}
// Add event listeners to all copy buttons
function initializeCopyButtons() {
  document.querySelectorAll('.copy-btn').forEach(button => {
    button.addEventListener('click', copyReferenceText);
  });
}
function updateSliderValue(slider) {
  // Find the value display within the slider's container
  const container = slider.parentElement;
  const valueSpan = container.querySelector('.slider-handle-value');

  // Update the displayed value
  valueSpan.textContent = slider.value;

  // Calculate the slider width and current percentage position
  const sliderWidth = slider.offsetWidth;
  const min = parseFloat(slider.min);
  const max = parseFloat(slider.max);
  const value = parseFloat(slider.value);
  const percentage = (value - min) / (max - min);

  // Update the label's horizontal position
  const handlePos = percentage * sliderWidth;
  valueSpan.style.left = handlePos + "px";
}

  document.getElementById('treeloc-conf-thresh').addEventListener('input', function() {
    updateSliderValue(this);
  });
  document.getElementById('treeloc-nms-thresh').addEventListener('input', function() {
    updateSliderValue(this);
  });
  document.getElementById('treeisonet-image').src = 'img/treeisonet_any.jpg';
  </script>
</body>
</html>